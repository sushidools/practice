"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Merge two enums into one
 * The derived will overwrite duplicate keys from base
 *
 * @export
 * @template T
 * @template R
 * @param {T} base
 * @param {R} derived
 * @returns {(T & R)}
 */
function mergeEnums(base, derived) {
    // the 'any' type is apparently necessary as TypeScript freaks out with error:
    // Spread types may only be created from object types.
    return __assign({}, base, derived);
    /**
     * Below was considered and rejected because for this use case it should not matter if
     * two text entries point to the same number, even though the number will only point to
     * the derived values
     *
     * Also I currently don't know of a way to type (T ^ R) & R
     * Or would it be T & ^(T | R) & R
     * or....
     */
    // const entries = Object.entries(derived);
    // entries.length /= 2;
    // return entries.reduce((memo, [key, value]) => {
    //   const remove = memo[key];
    //   delete memo[remove];
    //   return {
    //     ...memo,
    //     [key]: value,
    //     [value]: key
    //   }
    // }, Object.assign(base));
}
exports.mergeEnums = mergeEnums;
//# sourceMappingURL=helpers.js.map